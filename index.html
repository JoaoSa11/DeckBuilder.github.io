<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic: The Gathering Deckbuilder</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='50' fill='%236B21A8'/%3E%3Cpath d='M30 70 L30 30 L50 50 L70 30 L70 70' stroke='white' stroke-width='10' fill='none'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilo para a barra de rolagem */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* bg-gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* bg-gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* bg-gray-500 */
        }
        .card-image-container {
            position: relative;
        }
        .card-image {
            transition: transform 0.2s ease-in-out;
        }
        .card-image-container:hover .card-image {
            transform: scale(1.05);
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold">Magic Deckbuilder</h1>
            <p class="text-gray-400 mt-2">Encontre recomendações para seu comandante com base na sua coleção.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            <!-- Coluna da Coleção -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg col-span-1 lg:col-span-1">
                <h2 class="text-2xl font-semibold mb-4 border-b border-gray-600 pb-2 flex items-center">
                    1. Sua Coleção
                    <div id="collection-loader" class="loader hidden ml-4" style="width: 20px; height: 20px; border-width: 2px;"></div>
                </h2>
                <input type="file" id="collection-file-input" accept=".txt" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 cursor-pointer mb-4">
                <input type="text" id="collection-search-input" placeholder="Buscar na sua coleção..." class="w-full bg-gray-700 text-white p-2 rounded-md mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <div id="collection-list" class="h-96 overflow-y-auto pr-2">
                    <p class="text-gray-500">Nenhuma coleção carregada.</p>
                </div>
            </div>

            <!-- Coluna de Recomendações -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg col-span-1 lg:col-span-2">
                <h2 class="text-2xl font-semibold mb-4 border-b border-gray-600 pb-2">2. Buscar Recomendações</h2>
                <div class="flex flex-col sm:flex-row gap-4 mb-4">
                    <input type="text" id="commander-input" placeholder="Digite o nome do comandante" class="flex-grow bg-gray-700 text-white p-2 rounded-md border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="fetch-recommendations-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center">
                        <span id="btn-text">Buscar</span>
                        <div id="btn-loader" class="loader hidden ml-2"></div>
                    </button>
                </div>
                <div id="recommendations-scroll-container" class="h-[30rem] overflow-y-auto p-2">
                    <p id="recommendations-placeholder" class="text-gray-500 col-span-full text-center">Aguardando busca...</p>
                </div>
            </div>
            
            <!-- Coluna do Deck -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg col-span-1 lg:col-span-2">
                 <h2 class="text-2xl font-semibold mb-4 border-b border-gray-600 pb-2">
                    Deck (<span id="deck-count">0</span>/100)
                </h2>
                <div id="deck-list" class="h-[34.5rem] overflow-y-auto pr-2">
                    <p class="text-gray-500">Adicione cartas das recomendações.</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        // =========================================================================================
        // IMPORTANTE: Após hospedar seu backend, cole a URL pública dele aqui dentro das aspas.
        // Exemplo: const backendUrl = 'https://meu-deckbuilder-backend.onrender.com';
        // =========================================================================================
        const backendUrl = 'https://mtgdeckbuilder-iu6t.onrender.com'; // Mude esta linha quando tiver a URL!
        
        const collectionFileInput = document.getElementById('collection-file-input');
        const collectionListDiv = document.getElementById('collection-list');
        const collectionSearchInput = document.getElementById('collection-search-input');
        const commanderInput = document.getElementById('commander-input');
        const fetchBtn = document.getElementById('fetch-recommendations-btn');
        const recommendationsScrollContainer = document.getElementById('recommendations-scroll-container');
        const recommendationsPlaceholder = document.getElementById('recommendations-placeholder');
        const btnText = document.getElementById('btn-text');
        const btnLoader = document.getElementById('btn-loader');
        const deckListDiv = document.getElementById('deck-list');
        const deckCountSpan = document.getElementById('deck-count');
        const collectionLoader = document.getElementById('collection-loader');

        let user_collection = [];
        let deck_cards = [];
        let basic_lands = {};
        let scryfallApiCache = new Map();
        let recommendationsStore = new Map();
        let isCommanderSearched = false;
        let commanderColorIdentity = [];
        const colorToLandMap = { 'W': 'Plains', 'U': 'Island', 'B': 'Swamp', 'R': 'Mountain', 'G': 'Forest' };

        // --- Lógica da Coleção ---

        collectionFileInput.addEventListener('change', handleFileSelect);
        collectionSearchInput.addEventListener('input', () => renderCollection());
        
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            collectionLoader.classList.remove('hidden');
            collectionListDiv.innerHTML = '<p class="text-gray-500">Processando coleção... Isso pode levar um momento.</p>';
            isCommanderSearched = false;
            deck_cards = [];
            basic_lands = {};
            renderDeck();
            recommendationsScrollContainer.innerHTML = '<p id="recommendations-placeholder" class="text-gray-500 col-span-full text-center">Aguardando busca...</p>';

            const text = await file.text();
            const parsedCollection = parseManaBoxTxt(text);
            console.log('Coleção parseada:', parsedCollection.length, 'cartas únicas');
            await fetchCollectionData(parsedCollection);
            collectionLoader.classList.add('hidden');
            renderCollection();
        }

        async function fetchCollectionData(parsedCollection) {
            const CHUNK_SIZE = 75;
            const allIdentifiers = parsedCollection.map(c => ({ name: c.name }));
            const quantityMap = new Map(parsedCollection.map(c => [c.name, c.quantity]));
            let fullCollectionData = [];

            for (let i = 0; i < allIdentifiers.length; i += CHUNK_SIZE) {
                const chunk = allIdentifiers.slice(i, i + CHUNK_SIZE);
                try {
                    const response = await fetch(`https://api.scryfall.com/cards/collection`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ identifiers: chunk })
                    });
                    if (!response.ok) {
                        console.error(`Erro ao buscar dados da coleção para o chunk ${i / CHUNK_SIZE}`);
                        continue;
                    }
                    const result = await response.json();
                    if (result.not_found && result.not_found.length > 0) {
                        console.warn('Scryfall não encontrou as seguintes cartas:', result.not_found.map(c => c.name));
                    }
                    if (result.data && result.data.length > 0) {
                        const processedChunk = result.data.map(card => {
                            const simpleName = card.name.split('//')[0].trim();
                            return { ...card, quantity: quantityMap.get(simpleName) };
                        }).filter(card => card.quantity); // Garante que apenas cartas com quantidade sejam adicionadas
                        fullCollectionData.push(...processedChunk);
                    }
                } catch (error) {
                    console.error('Falha na requisição de coleção:', error);
                }
            }
            user_collection = fullCollectionData;
            console.log('Dados da coleção enriquecidos do Scryfall:', user_collection);
        }
        
        function parseManaBoxTxt(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            const collection = [];
            const regex = /^(\d+)\s+([^()]+)/;
            for (const line of lines) {
                const match = line.trim().match(regex);
                if (match) {
                    const quantity = parseInt(match[1], 10);
                    let name = match[2].trim();
                    if (name.includes('//')) {
                        name = name.split('//')[0].trim();
                    }
                    collection.push({ name, quantity });
                }
            }
            return collection;
        }

        function renderCollection() {
            collectionListDiv.innerHTML = '';
            if (user_collection.length === 0) {
                collectionListDiv.innerHTML = '<p class="text-gray-500">Nenhuma coleção carregada.</p>';
                return;
            }

            let collectionToDisplay = user_collection;

            if (isCommanderSearched && commanderColorIdentity.length > 0) {
                collectionToDisplay = user_collection.filter(card => isCardColorIdentityAllowed(card.color_identity, commanderColorIdentity));
            }

            const searchTerm = collectionSearchInput.value.toLowerCase();
            const filteredCollection = collectionToDisplay.filter(card => card.name.toLowerCase().includes(searchTerm));
            
            if (filteredCollection.length === 0) {
                 collectionListDiv.innerHTML = '<p class="text-gray-500">Nenhum card encontrado na busca.</p>';
                return;
            }

            filteredCollection.forEach(card => {
                const cardDiv = document.createElement('div');

                if (isCommanderSearched) {
                    cardDiv.className = 'p-2 rounded-md hover:bg-gray-700 flex justify-between items-center cursor-pointer group';
                    cardDiv.title = `Adicionar "${card.name}" ao deck`;
                    cardDiv.onclick = () => addCardFromCollectionToDeck(card.name);
                    
                    cardDiv.innerHTML = `
                        <span class="truncate">${card.name}</span>
                        <div class="flex items-center">
                            <span class="font-semibold text-gray-400 mr-2">${card.quantity}x</span>
                            <span class="text-green-400 opacity-0 group-hover:opacity-100 transition-opacity font-bold">+</span>
                        </div>
                    `;
                } else {
                    cardDiv.className = 'p-2 rounded-md flex justify-between items-center cursor-not-allowed opacity-50';
                    cardDiv.title = `Busque um comandante para habilitar a adição de cartas da coleção.`;
                    
                    cardDiv.innerHTML = `
                        <span class="truncate">${card.name}</span>
                        <div class="flex items-center">
                            <span class="font-semibold text-gray-400 mr-2">${card.quantity}x</span>
                        </div>
                    `;
                }
                collectionListDiv.appendChild(cardDiv);
            });
        }
        
        // --- Lógica de Recomendações e Cores ---
        
        fetchBtn.addEventListener('click', handleFetchRecommendations);

        async function getScryfallData(cardName, exact = false) {
            // Tenta pegar do cache de coleção primeiro, que é mais rico
            const cachedCard = user_collection.find(c => c.name === cardName);
            if(cachedCard) return cachedCard;
            
            if (scryfallApiCache.has(cardName)) {
                return scryfallApiCache.get(cardName);
            }
            try {
                const endpoint = exact ? `exact` : `fuzzy`;
                let response = await fetch(`https://api.scryfall.com/cards/named?${endpoint}=${encodeURIComponent(cardName)}`);
                if (!response.ok && exact) {
                    response = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`);
                }
                if (!response.ok) throw new Error(`Card not found: ${cardName}`);
                const cardData = await response.json();
                scryfallApiCache.set(cardName, cardData);
                scryfallApiCache.set(cardData.name, cardData);
                return cardData;
            } catch (error) {
                console.error(`Could not fetch data for ${cardName}:`, error);
                return null;
            }
        }

        function isCardColorIdentityAllowed(cardColors, commanderColors) {
            if (!cardColors || cardColors.length === 0) {
                return true; // Cartas incolores são sempre permitidas
            }
            return cardColors.every(color => commanderColors.includes(color));
        }

        async function handleFetchRecommendations() {
            const commanderName = commanderInput.value.trim();
            if (!commanderName) { alert('Por favor, digite o nome de um comandante.'); return; }
            if (user_collection.length === 0) { alert('Por favor, carregue sua coleção primeiro.'); return; }
            
            setLoadingState(true);
            recommendationsScrollContainer.innerHTML = '';
            recommendationsPlaceholder.textContent = 'Buscando comandante e recomendações...';
            recommendationsScrollContainer.appendChild(recommendationsPlaceholder);
            
            deck_cards = [];
            basic_lands = {};
            recommendationsStore.clear();
            isCommanderSearched = false;
            commanderColorIdentity = [];
            renderCollection();

            try {
                const commanderCardData = await getScryfallData(commanderName);
                 if (!commanderCardData) {
                    throw new Error(`Comandante "${commanderName}" não encontrado.`);
                }
                commanderColorIdentity = commanderCardData.color_identity;
                commanderColorIdentity.forEach(color => {
                    const landName = colorToLandMap[color];
                    if (landName) {
                        basic_lands[landName] = 0;
                    }
                });
                
                const response = await fetch(`${backendUrl}/recommendations/${encodeURIComponent(commanderName)}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `Erro na requisição: ${response.status}`);
                }
                const recommendations = await response.json();
                recommendationsStore.set(commanderCardData.id, recommendations);
                
                isCommanderSearched = true;
                addCardToDeck(commanderCardData);
                
                const ownedRecs = recommendations.filter(cardName =>
                    user_collection.some(ownedCard => ownedCard.name.toLowerCase() === cardName.toLowerCase())
                );
                
                const cardDataPromises = ownedRecs.map(name => getScryfallData(name));
                const allCardData = (await Promise.all(cardDataPromises)).filter(Boolean);
                const colorFilteredCards = allCardData.filter(card => isCardColorIdentityAllowed(card.color_identity, commanderColorIdentity));
                const finalRecNames = colorFilteredCards.map(card => card.name.split('//')[0].trim());
                
                const filteredRecs = finalRecNames.filter(cardName => cardName.toLowerCase() !== commanderCardData.name.split('//')[0].trim().toLowerCase());
                
                renderRecommendations(commanderCardData, filteredRecs, true);
                renderCollection();

            } catch (error) {
                console.error('Erro ao buscar recomendações:', error);
                recommendationsScrollContainer.innerHTML = `<p class="text-red-500 col-span-full text-center">${error.message}</p>`;
                deck_cards = [];
                basic_lands = {};
                renderDeck();
                isCommanderSearched = false;
                renderCollection();
            } finally {
                setLoadingState(false);
            }
        }
        
        async function renderRecommendations(legendData, cardList, isPrimary) {
            if (isPrimary) {
                recommendationsScrollContainer.innerHTML = '';
            }

            if (cardList.length === 0 && isPrimary) {
                recommendationsPlaceholder.textContent = 'Nenhuma carta recomendada (dentro da identidade de cor) foi encontrada na sua coleção.';
                recommendationsScrollContainer.appendChild(recommendationsPlaceholder);
                return;
            }
            if (cardList.length === 0 && !isPrimary) {
                console.log(`Nenhuma recomendação nova para "${legendData.name}" encontrada na sua coleção.`);
                return;
            }

            const sectionContainer = document.createElement('div');
            sectionContainer.id = `recs-for-${legendData.id}`;
            sectionContainer.className = isPrimary ? '' : 'mt-8 pt-4 border-t border-gray-700';
            
            const title = document.createElement('h3');
            title.className = 'text-xl font-semibold mb-3';
            title.textContent = `Recomendações para ${legendData.name}`;
            sectionContainer.appendChild(title);

            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-4 gap-4';
            sectionContainer.appendChild(gridDiv);

            recommendationsScrollContainer.appendChild(sectionContainer);
            
            cardList.sort((a, b) => a.localeCompare(b));

            for (const cardName of cardList) {
                const cardElement = createCardElement(cardName);
                gridDiv.appendChild(cardElement);
                fetchAndDisplayCardImage(cardName, cardElement);
            }
        }

        function createCardElement(cardName) {
            const container = document.createElement('div');
            container.className = 'card-image-container w-[150px] h-[209px] md:w-[180px] md:h-[251px] flex items-center justify-center bg-gray-700 rounded-lg overflow-hidden shadow-md cursor-pointer';
            container.title = `Adicionar "${cardName}" ao deck`;
            container.innerHTML = `<div class="loader"></div>`;
            return container;
        }

        async function fetchAndDisplayCardImage(cardName, element) {
            try {
                const cardData = await getScryfallData(cardName);
                if (!cardData) throw new Error('Card not found');
                const imageUrl = cardData.image_uris?.normal || 'https://placehold.co/220x307/1f2937/718096?text=No+Image';
                element.innerHTML = `<img src="${imageUrl}" alt="${cardName}" class="card-image w-full h-full object-cover" loading="lazy">`;
                element.onclick = () => addCardToDeck(cardData, element);
            } catch (error) {
                console.error(`Could not fetch image for ${cardName}:`, error);
                element.innerHTML = `<img src="https://placehold.co/220x307/1f2937/718096?text=No+Image" alt="Image not found" class="w-full h-full object-cover">`;
            }
        }

        // --- Lógica do Deck ---

        async function addCardFromCollectionToDeck(cardName) {
            console.log(`Tentando adicionar "${cardName}" da coleção.`);
            const cardData = user_collection.find(card => card.name === cardName || card.name.split('//')[0].trim() === cardName);
            
            if (!cardData) {
                alert(`Erro: não foi possível encontrar os dados para "${cardName}" na coleção local.`);
                return;
            }
            
            if (!isCardColorIdentityAllowed(cardData.color_identity, commanderColorIdentity)) {
                alert(`A carta "${cardData.name}" (${cardData.color_identity.join('')}) não pertence à identidade de cor do comandante (${commanderColorIdentity.join('')}).`);
                return;
            }
            
            addCardToDeck(cardData);
        }

        async function addCardToDeck(cardData, clickedElement = null) {
            if (cardData.type_line.toLowerCase().includes('basic land')) {
                alert('Para adicionar terrenos básicos, use os controles na seção "Deck".');
                return;
            }

            if (getTotalDeckCount() >= 100) { alert("O deck já tem 100 cartas."); return; }
            const isAlreadyInDeck = deck_cards.some(card => card.id === cardData.id);
            if (isAlreadyInDeck) { console.log(`${cardData.name} já está no deck.`); return; }
            
            deck_cards.push(cardData);
            renderDeck();

            // Lógica para remover a carta de TODAS as listas de recomendações
            const cardSimpleName = cardData.name.split('//')[0].trim();
            const allRecImgElements = recommendationsScrollContainer.querySelectorAll(`img[alt="${cardSimpleName}"]`);

            allRecImgElements.forEach(imgElement => {
                const container = imgElement.parentElement;
                if (container) {
                    const grid = container.parentElement;
                    container.remove();
                    if (grid && grid.children.length === 0) {
                        const section = grid.parentElement;
                        if (section && section.id.startsWith('recs-for-')) {
                            section.remove();
                        }
                    }
                }
            });

            const remainingSections = recommendationsScrollContainer.querySelectorAll('div[id^="recs-for-"]');
            if (remainingSections.length === 0 && isCommanderSearched) {
                recommendationsScrollContainer.innerHTML = '';
                recommendationsPlaceholder.textContent = 'Todas as recomendações foram adicionadas ao deck.';
                recommendationsScrollContainer.appendChild(recommendationsPlaceholder);
            }

            const typeLine = cardData.type_line.toLowerCase();
            const isLegendaryCreature = typeLine.includes('legendary') && typeLine.includes('creature');
            const isCommander = deck_cards.length > 0 && cardData.id === deck_cards[0].id;

            if (isLegendaryCreature && !isCommander) {
                console.log(`Criatura lendária adicionada: ${cardData.name}. Buscando recomendações secundárias.`);
                await fetchSecondaryRecommendations(cardData);
            }
        }

        async function fetchSecondaryRecommendations(legendCardData) {
            try {
                const response = await fetch(`${backendUrl}/recommendations/${encodeURIComponent(legendCardData.name)}`);
                if (!response.ok) {
                    console.error(`Não foi possível buscar recomendações secundárias para ${legendCardData.name}`);
                    return;
                }
                const newRecs = await response.json();
                recommendationsStore.set(legendCardData.id, newRecs);
                
                const deckCardNames = deck_cards.map(c => c.name.split('//')[0].trim().toLowerCase());
                
                const ownedRecs = newRecs.filter(recName => {
                    const recNameLower = recName.toLowerCase();
                    return user_collection.some(ownedCard => ownedCard.name.toLowerCase() === recNameLower) && !deckCardNames.includes(recNameLower);
                });

                const cardDataPromises = ownedRecs.map(name => getScryfallData(name));
                const allCardData = (await Promise.all(cardDataPromises)).filter(Boolean);
                const colorFilteredCards = allCardData.filter(card => isCardColorIdentityAllowed(card.color_identity, commanderColorIdentity));
                const finalRecNames = colorFilteredCards.map(card => card.name.split('//')[0].trim());

                if (finalRecNames.length > 0) {
                    console.log(`Adicionando ${finalRecNames.length} novas recomendações para ${legendCardData.name}.`);
                    renderRecommendations(legendCardData, finalRecNames, false);
                } else {
                    console.log(`Nenhuma recomendação nova para "${legendCardData.name}" encontrada na sua coleção.`);
                }
            } catch (error) {
                console.error(`Erro ao buscar recomendações secundárias para ${legendCardData.name}:`, error);
            }
        }


        function removeCardFromDeck(cardId) {
            const cardIndex = deck_cards.findIndex(card => card.id === cardId);
            if (cardIndex > -1) {
                const removedCard = { ...deck_cards[cardIndex] };
                deck_cards.splice(cardIndex, 1);
                renderDeck();

                const typeLine = removedCard.type_line.toLowerCase();
                const isLegendaryCreature = typeLine.includes('legendary') && typeLine.includes('creature');
                
                if (isLegendaryCreature) {
                    const sectionToRemove = document.getElementById(`recs-for-${removedCard.id}`);
                    if (sectionToRemove) {
                        sectionToRemove.remove();
                    }
                }
                
                const cardSimpleName = removedCard.name.split('//')[0].trim();
                
                const legendsWithRecs = Array.from(recommendationsStore.keys());
                const allLegendsInDeckOrCommander = [ ...deck_cards.filter(c => c.type_line.toLowerCase().includes('legendary')), deck_cards[0] ].filter(Boolean);
                
                const relevantLegendIds = new Set(allLegendsInDeckOrCommander.map(l => l.id));

                for (const legendId of legendsWithRecs) {
                    const legendData = user_collection.find(c => c.id === legendId) || deck_cards.find(c => c.id === legendId);
                    if (legendData && relevantLegendIds.has(legendData.id)) {
                        const originalRecs = recommendationsStore.get(legendData.id);
                        if (originalRecs && originalRecs.includes(cardSimpleName)) {
                            addCardBackToRecommendations(legendData, cardSimpleName);
                        }
                    }
                }

                
                const remainingRecs = recommendationsScrollContainer.querySelector('img');
                if (!remainingRecs && isCommanderSearched) {
                    recommendationsScrollContainer.innerHTML = '';
                    recommendationsPlaceholder.textContent = 'Nenhuma recomendação disponível.';
                    recommendationsScrollContainer.appendChild(recommendationsPlaceholder);
                }
            }
        }

        function addCardBackToRecommendations(legendData, cardNameToAdd) {
            if (recommendationsPlaceholder.parentElement === recommendationsScrollContainer) {
                recommendationsPlaceholder.remove();
            }

            let section = document.getElementById(`recs-for-${legendData.id}`);
            let gridDiv;

            if (!section) {
                const isPrimary = deck_cards.length > 0 && legendData.id === deck_cards[0].id;
                
                section = document.createElement('div');
                section.id = `recs-for-${legendData.id}`;
                section.className = isPrimary ? '' : 'mt-8 pt-4 border-t border-gray-700';
                
                const title = document.createElement('h3');
                title.className = 'text-xl font-semibold mb-3';
                title.textContent = `Recomendações para ${legendData.name}`;
                section.appendChild(title);

                gridDiv = document.createElement('div');
                gridDiv.className = 'grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-4 gap-4';
                section.appendChild(gridDiv);
                recommendationsScrollContainer.appendChild(section);
            } else {
                gridDiv = section.querySelector('.grid');
            }

            if (gridDiv) {
                const alreadyExists = Array.from(gridDiv.querySelectorAll('img')).some(img => img.alt === cardNameToAdd);
                if (!alreadyExists) {
                    const cardElement = createCardElement(cardNameToAdd);
                    gridDiv.appendChild(cardElement);
                    fetchAndDisplayCardImage(cardNameToAdd, cardElement);
                    
                    const cards = Array.from(gridDiv.children);
                    cards.sort((a, b) => a.title.localeCompare(b.title));
                    cards.forEach(card => gridDiv.appendChild(card));
                }
            }
        }
        
        function getTotalDeckCount() {
            const totalBasicLands = Object.values(basic_lands).reduce((sum, count) => sum + count, 0);
            return deck_cards.length + totalBasicLands;
        }

        function changeBasicLandCount(landName, amount) {
            const currentCount = basic_lands[landName];
            
            if (currentCount + amount < 0) return;

            if (amount > 0 && getTotalDeckCount() >= 100) {
                alert("O deck já tem 100 cartas.");
                return;
            }

            basic_lands[landName] += amount;
            renderDeck(); 
        }

        function renderDeck() {
            deckCountSpan.textContent = getTotalDeckCount();
            deckListDiv.innerHTML = '';
            
            if (deck_cards.length === 0) {
                deckListDiv.innerHTML = '<p class="text-gray-500">Adicione cartas das recomendações.</p>';
                return;
            }

            // Renderiza os controles de terrenos básicos
            if (Object.keys(basic_lands).length > 0) {
                const manaDiv = document.createElement('div');
                manaDiv.className = 'mb-4 p-3 bg-gray-700/50 rounded-lg';
                const manaTitle = document.createElement('h4');
                manaTitle.className = 'font-semibold text-gray-300 mb-2';
                manaTitle.textContent = 'Terrenos Básicos';
                manaDiv.appendChild(manaTitle);

                for (const landName in basic_lands) {
                    const controlDiv = document.createElement('div');
                    controlDiv.className = 'flex justify-between items-center py-1';
                    controlDiv.innerHTML = `
                        <span class="text-sm">${landName}</span>
                        <div class="flex items-center gap-3">
                            <button class="bg-red-600 hover:bg-red-700 w-6 h-6 rounded-full font-bold text-lg flex items-center justify-center transition-colors">-</button>
                            <span class="font-semibold w-6 text-center text-lg">${basic_lands[landName]}</span>
                            <button class="bg-green-600 hover:bg-green-700 w-6 h-6 rounded-full font-bold text-lg flex items-center justify-center transition-colors">+</button>
                        </div>
                    `;
                    controlDiv.querySelector('.bg-red-600').onclick = () => changeBasicLandCount(landName, -1);
                    controlDiv.querySelector('.bg-green-600').onclick = () => changeBasicLandCount(landName, 1);
                    manaDiv.appendChild(controlDiv);
                }
                deckListDiv.appendChild(manaDiv);
            }

            // Agrupa e renderiza as outras cartas
            const other_cards = deck_cards.filter(c => c.id !== deck_cards[0].id); // Exclui o comandante para renderizá-lo separadamente
            const groupedDeck = { Creature: [], Instant: [], Sorcery: [], Artifact: [], Enchantment: [], Planeswalker: [], Land: [], Other: [] };
            
            // Adiciona o comandante primeiro
            const commanderCard = deck_cards[0];
            const commanderDiv = document.createElement('div');
            commanderDiv.className = 'p-1.5 rounded-md flex justify-between items-center text-sm mb-3';
            commanderDiv.innerHTML = `<span class="truncate font-bold text-yellow-400">${commanderCard.name} (C)</span>`;
            deckListDiv.appendChild(commanderDiv);
            
            other_cards.forEach(card => {
                const typeLine = card.type_line.toLowerCase();
                if (typeLine.includes('creature')) groupedDeck.Creature.push(card);
                else if (typeLine.includes('instant')) groupedDeck.Instant.push(card);
                else if (typeLine.includes('sorcery')) groupedDeck.Sorcery.push(card);
                else if (typeLine.includes('artifact')) groupedDeck.Artifact.push(card);
                else if (typeLine.includes('enchantment')) groupedDeck.Enchantment.push(card);
                else if (typeLine.includes('planeswalker')) groupedDeck.Planeswalker.push(card);
                else if (typeLine.includes('land')) groupedDeck.Land.push(card);
                else groupedDeck.Other.push(card);
            });

            for (const group in groupedDeck) {
                if (groupedDeck[group].length > 0) {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'mb-3';
                    const groupTitle = document.createElement('h4');
                    groupTitle.className = 'font-semibold text-gray-300 mb-1';
                    groupTitle.textContent = `${group} (${groupedDeck[group].length})`;
                    groupDiv.appendChild(groupTitle);

                    groupedDeck[group].sort((a, b) => a.name.localeCompare(b.name)).forEach(card => {
                        const cardDiv = document.createElement('div');
                        cardDiv.className = 'p-1.5 rounded-md hover:bg-gray-700 flex justify-between items-center text-sm';
                        cardDiv.innerHTML = `<span class="truncate">${card.name}</span>`;
                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'text-red-500 hover:text-red-400 font-bold ml-2 px-2';
                        removeBtn.textContent = '×';
                        removeBtn.onclick = () => removeCardFromDeck(card.id);
                        cardDiv.appendChild(removeBtn);
                        groupDiv.appendChild(cardDiv);
                    });
                    deckListDiv.appendChild(groupDiv);
                }
            }
        }

        function setLoadingState(isLoading) {
            if (isLoading) {
                fetchBtn.disabled = true;
                btnText.classList.add('hidden');
                btnLoader.classList.remove('hidden');
            } else {
                fetchBtn.disabled = false;
                btnText.classList.remove('hidden');
                btnLoader.classList.add('hidden');
            }
        }
    </script>
</body>
</html>

